#pragma once

// This component provides a struct, `TracerConfig`, used to configure a
// `Tracer`.  `Tracer` is instantiated with a `FinalizedTracerConfig`, which
// must be obtained from the result of a call to `finalize_config`.

#include <chrono>
#include <cstddef>
#include <memory>
#include <variant>
#include <vector>

#include "clock.h"
#include "datadog/event_scheduler.h"
#include "datadog/http_client.h"
#include "datadog_agent_config.h"
#include "error.h"
#include "expected.h"
#include "propagation_style.h"
#include "runtime_id.h"
#include "span_defaults.h"
#include "span_sampler_config.h"
#include "trace_sampler_config.h"

namespace datadog {
namespace tracing {

class Collector;
class Logger;
class SpanSampler;
class TraceSampler;

// `FinalizedTracerConfig` contains `Tracer` implementation details derived from
// a valid `TracerConfig` and accompanying environment.
// `FinalizedTracerConfig` must be obtained by calling `finalize_config`.
class FinalizedTracerConfig {
  friend class TracerConfig;
  FinalizedTracerConfig() = default;

 public:
  SpanDefaults defaults;

  std::shared_ptr<Collector> collector;

  FinalizedDatadogAgentConfig agent_config;
  FinalizedTraceSamplerConfig trace_sampler;
  FinalizedSpanSamplerConfig span_sampler;

  std::vector<PropagationStyle> injection_styles;
  std::vector<PropagationStyle> extraction_styles;

  bool report_traces;
  bool report_hostname;
  std::size_t tags_header_size;
  std::shared_ptr<Logger> logger;
  bool log_on_startup;
  bool trace_id_128_bit;
  bool report_telemetry;
  Optional<RuntimeID> runtime_id;
  Clock clock;
  std::string integration_name;
  std::string integration_version;
  bool delegate_trace_sampling;
};

class TracerConfig {
 public:
  TracerConfig();

  // Set the application name.
  //
  // Overriden by the `DD_SERVICE` environment variables.
  TracerConfig& service_name(std::string service_name);

  // All the rest are optional and can be most of the time overridden by
  // environment variables.
  TracerConfig& service_type(std::string service_type);

  // Set the application environment.
  //
  // Overriden by the `DD_ENV` environment variable.
  // Example: `prod`, `pre-prod` or `staging`.
  TracerConfig& service_environment(std::string environment);

  // Set the application version.
  //
  // Overriden by the `DD_VERSION` environment variable.
  // Example values: `1.2.3`, `6c44da20`, `2020.02.13`.
  TracerConfig& service_version(std::string version);

  // Set the default name for spans.
  TracerConfig& span_default_name(std::string name);

  // Set global tags to be attached to every span.
  //
  // Overriden by the `DD_TAGS` environment variable.
  TracerConfig& tags(std::unordered_map<std::string, std::string> tags);

  // `integration_name` is the name of the product integrating this library.
  // Example: "nginx", "envoy" or "istio".
  TracerConfig& integration_name(std::string name);

  // `integration_version` is the version of the product integrating this
  // library.
  // Example: "1.2.3", "6c44da20", "2020.02.13"
  TracerConfig& integration_version(std::string version);

  // A URL at which the Datadog Agent can be contacted.
  // The following formats are supported:
  //
  // - http://<domain or IP>:<port>
  // - http://<domain or IP>
  // - http+unix://<path to socket>
  // - unix://<path to socket>
  //
  // The port defaults to 8126 if it is not specified.
  //
  // Overriden by the `DD_TRACE_AGENT_URL` environment variable.
  TracerConfig& datadog_agent_url(std::string url);

  // Indicates whether traces generated by the tracer will be
  // sent to a collector (`true`) or discarded on completion (`false`).
  // If `report_traces` is `false`, then both `agent` and `collector` are
  // ignored.
  //
  // Overridden by the `DD_TRACE_ENABLED` environment variable.
  TracerConfig& report_traces(bool report_traces);

  // Indicates whether telemetry about the tracer will be send to a collector
  // a collector (`true`) or discarded on completion (`false`).
  // If `report_telemetry` is `false`, then this feature is disabled.
  //
  // Overridden by the `DD_INSTRUMENTATION_TELEMETRY_ENABLED` environment
  // variable.
  TracerConfig& report_telemetry(bool report_telemetry);

  // Indicates whether the tracer will generate 128-bit trace IDs.
  // If `true`, the tracer will generate 128-bit trace IDs. If false, the
  // tracer will generate 64-bit trace IDs.
  //
  // Overriden by the `DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED` environment
  // variable.
  TracerConfig& enable_128bit_trace_id(bool report_128bit_trace_id);

  // `log_on_startup` indicates whether the tracer will log a banner of
  // configuration information once initialized.
  //
  // Overridden by the `DD_TRACE_STARTUP_LOGS` environment variable.
  TracerConfig& log_configuration_on_startup(bool log_on_startup);

  // Indicates with which tracing systems trace propagation
  // will be compatible when injecting (sending) trace context.
  // All styles indicated by `injection_styles` are used for injection.
  //
  // Overridden by the `DD_TRACE_PROPAGATION_STYLE_INJECT`
  // and `DD_TRACE_PROPAGATION_STYLE` environment variables.
  TracerConfig& injection_styles(
      std::vector<PropagationStyle> injeciton_styles);

  // Indicates with which tracing systems trace propagation
  // will be compatible when extracting (receiving) trace context.
  // Extraction styles are applied in the order in which they appear in
  // `extraction_styles`. The first style that produces trace context or
  // produces an error determines the result of extraction.
  //
  // Overridden by the `DD_TRACE_PROPAGATION_STYLE_EXTRACT` and
  // `DD_TRACE_PROPAGATION_STYLE` environment variables.
  TracerConfig& extraction_styles(
      std::vector<PropagationStyle> extraction_styles);

  // `trace_sampler` configures trace sampling. Trace sampling determines which
  // traces are sent to Datadog.  See `trace_sampler_config.h`.
  //
  // Overriden by `DD_TRACE_SAMPLING_RULES`, `DD_TRACE_SAMPLE_RATE`
  // and `DD_TRACE_RATE_LIMIT` environment variables.
  TracerConfig& trace_sampler(TraceSamplerConfig trace_sampler);

  // `span_sampler` configures span sampling.  Span sampling allows specified
  // spans to be sent to Datadog even when their enclosing trace is dropped by
  // the trace sampler.  See `span_sampler_config.h`.
  //
  // Overriden by `DD_SPAN_SAMPLING_RULES` and `DD_SPAN_SAMPLING_RULES_FILE`
  // environment variables.
  TracerConfig& span_sampler(SpanSamplerConfig trace_sampler);

  // `delegate_trace_sampling` indicates whether the tracer will consult a child
  // service for a trace sampling decision, and prefer the resulting decision
  // over its own, if appropriate.
  //
  // Overriden by `DD_TRACE_DELEGATE_SAMPLING` environment variable.
  TracerConfig& delegate_trace_sampling(bool enable_sampling_deleation);

  // `report_hostname` indicates whether the tracer will include the result of
  // `gethostname` with traces sent to the collector.
  TracerConfig& report_hostname(bool report_hostname);

  // The `HTTPClient` used to submit traces to the Datadog Agent.  If this
  // library was built with libcurl (the default), then `http_client` is
  // optional: a `Curl` instance will be used if `http_client` is left null.
  // If this library was built without libcurl, then `http_client` is required
  // not to be null.
  TracerConfig& http_client(std::shared_ptr<HTTPClient> http_client);

  // The `EventScheduler` used to schedule recurring task like periodically
  // submit batches of traces to the `Collector`.
  // If `event_scheduler` is null, then a `ThreadedEventScheduler` instance will
  // be used instead.
  TracerConfig& event_scheduler(
      std::shared_ptr<EventScheduler> event_scheduler);

  // `flush_interval` denotes the duration, in milliseconds, between batches of
  // traces being sent to the `Collector`.
  TracerConfig& flush_interval(std::chrono::milliseconds flush_interval);

  // `request_timeout` denotes the maximum duration, in milliseconds, an HTTP
  // request is allowed to run.
  TracerConfig& request_timeout(std::chrono::milliseconds request_timeout);

  // `shutdown_timeout` denotes the maximum duration, in milliseconds, the
  // tracer allows work in progress before shutting down.
  TracerConfig& shutdown_timeout(std::chrono::milliseconds shutdown_timeout);

  // Set how often, in seconds, to query the Datadog Agent for remote
  // configuration updates.
  TracerConfig& remote_configuration_poll_interval(
      std::chrono::seconds poll_interval);

  // A `Collector` instance that the tracer will use to report traces.
  // If `collector` is null, then a `DatadogAgent` instance will be created.
  // Note that `collector` is ignored if `report_traces` is `false`.
  TracerConfig& collector(std::shared_ptr<Collector> collector);

  // `max_tags_header_size` is the maximum allowed size, in bytes, of the
  // serialized value of the "X-Datadog-Tags" header used when injecting trace
  // context for propagation.  If the serialized value of the header would
  // exceed `tags_header_size`, the header will be omitted instead.
  TracerConfig& max_tags_header_size(std::size_t max_tags_header_size);

  // `logger` specifies how the tracer will issue diagnostic messages. If
  // `logger` is null, then it defaults to a logger that inserts into
  // `std::cerr`.
  TracerConfig& logger(std::shared_ptr<Logger> logger);

  // `runtime_id` denotes the current run of the application in which the tracer
  // is embedded. If `runtime_id` is not specified, then it defaults to a
  // pseudo-randomly generated value. A server that contains multiple tracers,
  // such as those in the worker threads/processes of a reverse proxy, might
  // specify the same `runtime_id` for all tracer instances in the same run.
  TracerConfig& runtime_id(RuntimeID runtime_id);

  Expected<FinalizedTracerConfig> finalize() const;
  Expected<FinalizedTracerConfig> finalize(const Clock& clock) const;

 private:
  TraceSamplerConfig trace_sampler_;
  SpanSamplerConfig span_sampler_;
  DatadogAgentConfig agent_config;
  FinalizedTracerConfig config;
};

}  // namespace tracing
}  // namespace datadog
