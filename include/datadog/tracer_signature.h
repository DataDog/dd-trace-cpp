#pragma once

// This component provides a class, `TracerSignature`, that contains the parts
// of a tracer's configuration that are used to refer to the tracer in Datadog's
// telemetry and remote configuration APIs.
//
// `TracerSignature` is used in three contexts:
//
// 1. When telemetry is sent to the Datadog Agent, the tracer signature is
//    included in the request payload. See
//    `TracerTelemetry::generate_telemetry_body` in `tracer_telemetry.cpp`.
// 2. When the Datadog Agent is polled for configuration updates, part of the
//    tracer signature (all but the language version) is included in the request
//    payload. See `RemoteConfigurationManager::make_request_payload` in
//    `remote_config.h`.
// 3. When the Datadog Agent responds with configuration updates, the service
//    and environment of the tracer signature are used to determine whether the
//    updates are relevant to the `Tracer` that created the collector that is
//    polling the Datadog Agent. See
//    `RemoteConfigurationManager::process_response` in `remote_config.h`.

#ifdef __linux__
#include <cstring>
#include <memory>
#include <vector>
#endif

#include <string>

#include "runtime_id.h"
#include "string_view.h"
#include "version.h"

#define DD_TRACE_STRINGIFY(ARG) DD_TRACE_STRINGIFY_HELPER(ARG)
#define DD_TRACE_STRINGIFY_HELPER(ARG) #ARG

namespace datadog {
namespace tracing {

#ifdef __linux__
namespace {
void write_utf8_string(std::vector<uint8_t>& buffer, const std::string& str) {
  uint32_t length = str.length();
  buffer.insert(buffer.end(), reinterpret_cast<uint8_t*>(&length),
                reinterpret_cast<uint8_t*>(&length) + sizeof(length));
  buffer.insert(buffer.end(), str.begin(), str.end());
}
}  // namespace
#endif

struct TracerSignature {
  RuntimeID runtime_id;
  std::string default_service;
  std::string default_environment;
  std::string library_version;
  StringView library_language;
  StringView library_language_version;

  TracerSignature() = delete;
  TracerSignature(RuntimeID id, std::string service, std::string environment)
      : runtime_id(id),
        default_service(std::move(service)),
        default_environment(std::move(environment)),
        library_version(tracer_version),
        library_language("cpp"),
        library_language_version(DD_TRACE_STRINGIFY(__cplusplus), 6) {}

#ifdef __linux__
  // The process correlation storage contains information needed to
  // correlate traces to profiles generated by dd-otel-host-profiler.
  const std::unique_ptr<uint8_t*> generate_process_correlation_storage() {
    std::vector<uint8_t> buffer;

    // Currently, layout minor version is 2 to differ from Elastic's
    // version which includes a socket path.
    // Layout:
    // https://github.com/elastic/apm/blob/149cd3e39a77a58002344270ed2ad35357bdd02d/specs/agents/universal-profiling-integration.md#process-storage-layout
    uint16_t layout_minor_version = 2;
    buffer.insert(buffer.end(),
                  reinterpret_cast<uint8_t*>(&layout_minor_version),
                  reinterpret_cast<uint8_t*>(&layout_minor_version) +
                      sizeof(layout_minor_version));

    write_utf8_string(buffer, default_service);
    write_utf8_string(buffer, default_environment);
    write_utf8_string(buffer, runtime_id.string());

    uint8_t* res = new uint8_t[buffer.size()];
    memcpy(res, buffer.data(), buffer.size());
    return std::make_unique<uint8_t*>(res);
  }
#endif
};

}  // namespace tracing
}  // namespace datadog

#undef DD_TRACE_STRINGIFY_HELPER
#undef DD_TRACE_STRINGIFY
